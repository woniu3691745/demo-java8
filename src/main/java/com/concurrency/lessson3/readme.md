####锁
 + 避免死锁
 + 减小锁粒度
 + 锁分离
 
 > 一致性状态，线程上下文切换，调度
 
####有助于提高"锁"性能的几点建议
 + 减少持有锁的时间
    > 减少锁的持有时间有助于降低锁冲突的可能性，进而提升系统的并发能力。
 + 减小锁粒度
    > 所谓减少锁粒度，就是指缩小锁定对象的范围，从而减少锁冲突的可能性，进而提高系统的并发能力。
 + 读写分离锁来替换独占锁
    > 在读多写少的场合，使用读写锁可以有效提升系统的并发能力。
 + 锁分离
    > java.util.concurrent.LinkedBlockingQueue是基于链表的，用takeLock和putLock两把锁。
 + 锁粗化
    > 把所有的锁操作整合成对锁的一次请求，从而减少对锁的请求同步次数。
    
####JDK内部的"锁"优化策略
 + 偏向锁
 + 轻量级锁
 + 自旋锁
 + 锁消除
 
####ThreadLocal
> 一个线程的局部变量
> 为每一个线程分配不同的对象，需要在应用层面保证。ThreadLocal只是起到了简单的容器作用。

####比较交换（CAS）
> 包含三个参数CAS（V，E，N），V表示要更新的变量，E表示预期值，N表示新值。仅当V值等于E值时，才会将V的值设为N，如果V值和E值不同，则说明
已经有其他线程做了更新，则当前线程什么都不做。
 + v == e then v = n 
 + v != e then not do 
 
####无锁的线程安全整数：AtomicInteger
####无锁的对象引用：AtomicReference
####带有时间戳的对象引用：AtomicStampedReference
####数组也能无锁：AtomicIntegerArray
####让普通变量也享受原子操作：AtomicIntegerFieldUpdate

####死锁
 > 死锁就是两个或者多个线程，相互占用对方需要的资源，而都不进行释放，
 导致彼此之间都相互等待对方释放资源，产生了无限制等待的现象。
 + 避免死锁 
    + 无锁函数
    + 重入锁（中断或限时等待）